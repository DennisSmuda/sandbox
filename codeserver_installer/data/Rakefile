# Rakefile for codeserver project

require "fileutils"
require 'net/ftp'
require 'socket'

def my_exec cmd
  puts "[cmd] #{cmd}"
  system cmd
end

def kill_by_pid_file file_path
  return unless File.exists? file_path
  puts "Found pid file #{file_path}"
  pid = File.read file_path
  puts "Terminating process with pid #{pid}..."
  my_exec "kill -9 #{pid}"
  if File.exists? file_path
    FileUtils.rm file_path
  end
end

desc "Start code server"
task :start => :stop do
  my_exec "mkdir -p backup"
  my_exec "cd redmine-0.9.3 && ./script/server -d -e production"
  # fork a process which monitors gitosis project, also, writes the pid file
  sync_pid = fork do
    while true do
      Dir.foreach("git-repo") do |entry|
        next if entry.start_with? "."
        entry_path = "git-repo/#{entry}"
        next unless File.directory? entry_path
        `cd #{entry_path} && git fetch origin && git reset refs/remotes/origin/master`
      end
      sleep 30 # sleep a while, then update again
    end
  end
  File.open("git-repo/sync.pid", "w") do |f|
    f.write sync_pid
  end
  # fork a process which manages remote backup jobs
  backup_pid = fork do
    if File.exists? "backup.ini"
      sleep_interval = nil
      File.read("backup.ini").each_line do |line|
        line = line.strip
        if line.start_with? "interval="
          sleep_interval = line[9..-1].to_i
        end
      end
      if sleep_interval != nil
        while true do
          sleep sleep_interval * 60 # sleep unit is minutes
          system "rake backup:remote &"
        end
      end
    else
      puts "'backup.ini' not found, will not push backup to remote sites automatically!"
    end
  end
  File.open("backup/backup.pid", "w") do |f|
    f.write backup_pid
  end
  my_exec "svnserve -d -r ./svn-repo"
end

desc "Stop code server"
task :stop do
  if File.exists? "redmine-0.9.3/tmp/pids"
    Dir.foreach("redmine-0.9.3/tmp/pids") do |entry|
      kill_by_pid_file "redmine-0.9.3/tmp/pids/#{entry}" if entry.end_with? ".pid"
    end
  end
  kill_by_pid_file "git-repo/sync.pid"
  kill_by_pid_file "backup/backup.pid"
  my_exec "killall svnserve"
end

def gitosis_project_names conf
  names = []
  conf.each_line do |line|
    line = line.chomp
    if line.start_with? "[group "
      name = line[7..-2]
      names << name
    end
  end
  names
end

desc "Add new project"
task :gitnew do
  chdir "#{File.dirname __FILE__}/gitosis-admin"
  puts "name of new git project? (a-z, 0-9, _, -, must start with a-z): "
  name = STDIN.gets.chomp
  if name == "" or name !~ /^[a-z]+[a-z_\-0-9]*$/
    puts "error: illegal project name!"
    exit 1
  end
  conf = File.read "gitosis.conf"
  if gitosis_project_names(conf).include? name
    puts "error: git project #{name} already exists!"
    exit 1
  end
  sync_user = "#{ENV['USER']}@#{Socket.gethostname}"
  unless File.exists? "keydir/#{sync_user}.pub"
    FileUtils.cp "#{ENV["HOME"]}/.ssh/id_rsa.pub", "keydir/#{sync_user}.pub"
  end
  File.open("gitosis.conf", "a") do |f|
    f.write "\n"
    f.write "[group #{name}]\n"
    f.write "writable = #{name}\n"
    f.write "members = #{sync_user}\n"
    f.write "\n"
  end
  my_exec "git commit -a -m 'new project #{name}' && git push"
  chdir "#{File.dirname __FILE__}/git-repo"
  my_exec "mkdir #{name} && cd #{name} && git init && git remote add origin git@localhost:#{name}.git"
  puts "git project #{name} created, next step is to add some users"
  puts "done!"
end

desc "Add user to git project"
task :gitadduser do
  chdir "#{File.dirname __FILE__}/gitosis-admin"
  puts "name of git project project? "
  name = STDIN.gets.chomp
  if name == "" or name !~ /^[a-z]+[a-z_\-0-9]*$/
    puts "error: illegal project name!"
    exit 1
  end
  conf = File.read "gitosis.conf"
  unless gitosis_project_names(conf).include? name
    puts "error: git project #{name} does not exist!"
    exit 1
  end
  puts "username? (no white space, preferred: user@host) "
  user = STDIN.gets.chomp
  if user.include? " " or user.include? "\t"
    puts "illegal user name!"
    exit 1
  end
  if File.exists? "keydir/#{user}.pub"
    puts "user key file found: keydir/#{user}.pub"
  else
    puts "user key file not found in keydir!"
    puts "path to user key file? "
    key_in = STDIN.gets.chomp
    unless File.exists? key_in
      puts "key file #{key_in} not found!"
      exit 1
    end
    FileUtils.cp key_in, "keydir/#{user}.pub"
  end
  has_error = false
  File.open("gitosis.conf", "w") do |f|
    in_group = false
    conf.each_line do |line|
      if line.start_with? "[group #{name}]"
        in_group = true
      elsif line.start_with? "[group "
        in_group = false
      end
      if in_group and line.start_with? "members ="
        members = line.split[2..-1]
        if members.include? user
          puts "error: user #{user} already in git project #{name}!"
          has_error = true
        else
          puts "user #{user} added to git project #{name}"
          members << user
        end
        f.write "members = #{members.join " "}\n"
      else
        f.write line
      end
    end
  end
  unless has_error
    my_exec "git add ."
    my_exec "git commit -a -m 'add user #{user} to project #{name}' && git push"
  end
  puts "done!"
end

desc "Remove user from git project"
task :gitdeluser do
  chdir "#{File.dirname __FILE__}/gitosis-admin"
  puts "warning: it is highly advised that you delete git users by hand!"
  puts "name of git project project? "
  name = STDIN.gets.chomp
  if name == "" or name !~ /^[a-z]+[a-z_\-0-9]*$/
    puts "error: illegal project name!"
    exit 1
  end
  conf = File.read "gitosis.conf"
  unless gitosis_project_names(conf).include? name
    puts "error: git project #{name} does not exist!"
    exit 1
  end
  puts "username? (no white space) "
  user = STDIN.gets.chomp
  if user.include? " " or user.include? "\t"
    puts "illegal user name!"
    exit 1
  end
  has_error = false
  File.open("gitosis.conf", "w") do |f|
    in_group = false
    conf.each_line do |line|
      if line.start_with? "[group #{name}]"
        in_group = true
      elsif line.start_with? "[group "
        in_group = false
      end
      if in_group and line.start_with? "members ="
        members = line.split[2..-1]
        if members.include? user
          puts "user #{user} removed from git project #{name}"
          members.delete user
        else
          puts "error: user #{user} not in git project #{name}!"
          has_error = true
        end
        f.write "members = #{members.join " "}\n"
      else
        f.write line
      end
    end
  end
  all_members = []
  File.open("gitosis.conf").each_line do |line|
    if line.start_with? "members ="
      members = line.split[2..-1]
      all_members.concat members
    end
  end
  Dir.foreach("keydir") do |entry|
    next unless entry.end_with? ".pub"
    key_name = entry[0..-5]
    unless all_members.include? key_name
      puts "remove unused key file: keydir/#{entry}"
      FileUtils.rm "keydir/#{entry}"
      my_exec "git rm keydir/#{entry}"
    end
  end
  unless has_error
    my_exec "git commit -a -m 'remove user #{user} from project #{name}' && git push"
  end
  puts "done!"
end

desc "Add new svn project"
task :svnnew do
  chdir "#{File.dirname __FILE__}/svn-repo"
  puts "name of new svn project? (a-z, 0-9, _, -, must start with a-z): "
  name = STDIN.gets.chomp
  if name == "" or name !~ /^[a-z]+[a-z_\-0-9]*$/
    puts "error: illegal project name!"
    exit 1
  end
  puts "new svn project: #{name}"
  if File.exists? name
    puts "error: svn project #{name} already exists!"
    exit 1
  end
  puts "creating project repository..."
  system "svnadmin create #{name}"
  puts "configuring repository.."
  chdir "#{name}/conf"
  conf = File.read "svnserve.conf"
  File.open("svnserve.conf", "w") do |f|
    conf.each_line do |line|
      line = line.chomp
      if line.start_with? "# password-db = passwd"
        line = "password-db = passwd"
      elsif line.start_with? "# authz-db = authz"
        line = "authz-db = authz"
      elsif line.start_with? "# anon-access = read"
        line = "anon-access = none"
      elsif line.start_with? "# realm ="
        line = "realm = #{name}"
      end
      f.write line + "\n"
    end
  end
  File.open("authz", "a") do |f|
    f.write "\n"
    f.write '# added by "rake newsvn":' + "\n"
    f.write "[/]\n"
  end
  puts "done!"
end

desc "Add user to svn project"
task :svnadduser do
  puts "name of the svn project? "
  proj = STDIN.gets.chomp
  unless File.exists? "#{File.dirname __FILE__}/svn-repo/#{proj}"
    puts "error: svn project #{proj} does not exist!"
    exit 1
  end
  chdir "#{File.dirname __FILE__}/svn-repo/#{proj}/conf"
  puts "username (a-z, 0-9, _, -, must start with a-z): "
  user = STDIN.gets.chomp
  if user == "" or user !~ /^[a-z]+[a-z_\-0-9]*$/
    puts "error: illegal username!"
    exit 1
  end
  puts "password (at least 4 chars, cannot contain white space): "
  pwd = STDIN.gets.chomp
  if pwd.length < 4 or pwd.include? " " or pwd.include? "\t"
    puts "error: illegal password!"
    exit 1
  end
  authz = File.read "authz"
  authz.each_line do |line|
    if line.start_with? user
      puts "error: user #{user} already in svn project #{proj}"
      exit 1
    end
  end
  File.open("authz", "a") do |f|
    f.write "#{user} = rw\n"
  end
  File.open("passwd", "a") do |f|
    f.write "#{user} = #{pwd}\n"
  end
  puts "done!"
end

desc "Remove user from svn project"
task :svndeluser do
  puts "name of the svn project? "
  proj = STDIN.gets.chomp
  unless File.exists? "#{File.dirname __FILE__}/svn-repo/#{proj}"
    puts "error: svn project #{proj} does not exist!"
    exit 1
  end
  chdir "#{File.dirname __FILE__}/svn-repo/#{proj}/conf"
  puts "username: "
  user = STDIN.gets.chomp
  if user == "" or user !~ /^[a-z]+[a-z_\-0-9]$*/
    puts "error: illegal username!"
    exit 1
  end
  authz = File.read "authz"
  user_found = false
  authz.each_line do |line|
    if line.start_with? user
      user_found = true
      break
    end
  end
  unless user_found
    puts "error: user #{user} not found in project #{proj}!"
    exit 1
  end
  File.open("authz", "w") do |f|
    authz.each_line do |line|
      unless line.start_with? user
        f.write line
      end
    end
  end
  passwd = File.read "passwd"
  File.open("passwd", "w") do |f|
    passwd.each_line do |line|
      unless line.start_with? user
        f.write line + "\n"
      end
    end
  end
  puts "done!"
end

def do_backup
  chdir (File.dirname __FILE__)
  # git-gc all the git repos
  Dir.foreach("git-repo") do |entry|
    next if entry.start_with? "."
    fpath = File.join "git-repo", entry
    next unless File::directory? fpath
    system "cd #{fpath} && git gc"
  end
  time_now = Time.now
  time_str = "%04d%02d%02d%02d%02d%02d" % [time_now.year, time_now.month, time_now.day, time_now.hour, time_now.min, time_now.sec]
  system "
    mkdir -p backup/codeserver/gitosis-admin
    cp gitosis-admin/gitosis.conf backup/codeserver/gitosis-admin
    cp -r gitosis-admin/keydir backup/codeserver/gitosis-admin
    tar cvzf git-repo.tar.gz git-repo/
    mv git-repo.tar.gz backup/codeserver
    cp -r svn-repo backup/codeserver
    mkdir -p backup/codeserver/redmine-0.9.3/db
    cp redmine-0.9.3/db/production.db backup/codeserver/redmine-0.9.3/db
    cp -r redmine-0.9.3/files backup/codeserver/redmine-0.9.3
    cd backup
    tar cvzf codeserver.backup.#{time_str}.tar.gz codeserver/
    rm -rf codeserver
"
  return time_str
end

desc "Backup important data"
task :backup do
  do_backup
end

namespace :backup do
  desc "Backup, and also put to remote server"
  task :remote do
    time_str = do_backup
    # NOTE that we are all ready chdir'ed into (File.dirname __FILE__) by calling do_backup
    backup_file = "backup/codeserver.backup.#{time_str}.tar.gz"

    unless File.exists? "backup.ini"
      puts "'backup.ini' not found, cannot push to remote sites!"
      exit
    end

    remote_sites = []
    remote_site = nil
    File.read("backup.ini").each_line do |line|
      line = line.strip
      if line.start_with? "#" or line == ""
        next
      elsif line.start_with? "["
        if remote_site != nil
          remote_sites << remote_site
        end
        remote_site = {}
      elsif remote_site != nil
        idx = line.index "="
        key = line[0..(idx - 1)]
        value = line[(idx + 1)..-1]
        remote_site[key] = value
      end
    end
    if remote_site != nil
      remote_sites << remote_site
    end

    remote_sites.each do |remote_site|
      begin
        # makes folders
        conn = Net::FTP.new
        conn.connect remote_site["host"], remote_site["port"]
        conn.login remote_site["user"], remote_site["passwd"]
        path_split = (remote_site["dir"].split "/").select {|sp| sp != ""}
        path_split.each do |folder|
          begin
            conn.mkdir folder
          rescue
            # do nothing
          end
          conn.chdir folder
        end
        conn.close
        # put files by lftp
        File.open("lftp.script", "w") do |f|
          f.write <<LFTP_SCRIPT
set net:timeout 10
set net:max-retries 3
set net:reconnect-interval-base 1
open #{remote_site["user"]}:#{remote_site["passwd"]}@#{remote_site["host"]}:#{remote_site["port"]}
cd #{remote_site["dir"]}
put #{backup_file}
LFTP_SCRIPT
        end
        system "lftp -f lftp.script"
        FileUtils.rm "lftp.script"
      rescue
        next
      end
    end
  end
end

