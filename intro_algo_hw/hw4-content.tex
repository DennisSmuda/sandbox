\problem{8.2-4}
Describe an algorithm that, given $n$ intergers in the range $0$ to $k$, preprocesses its input and then answers any query about how many of the $n$ integers fall into a range
$[a\ldots b]$ in $O(1)$ time. Your algorithm should use $\Theta(n + k)$ preprocessing time.
\answer

The algorithm is given below. The \textsc{Preprocess} returns an array, which will be used by \textsc{Count-Interval}.

\begin{algorithm}[H]
\caption{\textsc{Preprocess}$(A, n, k)$}
Create array $C$ with size $k + 1$, index starts at $0$\\
\For{$i = 0$ to $k$}{
  $C[i] \leftarrow 0$
}
\For{$i = 1$ to $n$}{
  $C[A[i]] \leftarrow C[A[i]] + 1$
}
\tcp{Now $C[j]$ contains number of elements with value $j$}
\For{$i = 1$ to $k$}{
  $C[A[i]] \leftarrow C[A[i]] + C[A[i - 1]]$
}
\tcp{Now $C[j]$ contains number of elements in the range $[0, j]$}
\Return $C$
\end{algorithm}

\begin{algorithm}[H]
\caption{\textsc{Count-Interval}$(C, a, b)$}
\tcp{Array $C$ is returned by \textsc{Preprocess}$(A, n)$}
\If{$a \neq 0$}{
  \Return $C[b] - C[a - 1]$
}\Else{
  \Return $C[b]$
}
\end{algorithm}
\qed


\problem{8-4}
Suppose that you are given $n$ red and $n$ blue water jugs, all of different shapes and sizes. All red jugs hold different amounts of water, as do the blue ones. Moreover,
for every red jug, there is a blue jug that holds the same amount of water, and vice versa.

It is your task to find a grouping of the jugs into pairs of red and blue jugs that holds the same amount of water. To do so, you may perform the following operation:
pick a pair of jugs in which one is red and one is blue, fill the red jug with water, and then pour the water into the blue jug. This operation will tell you whether the red or
blue jug can hold more water, or if they are of the same volume. Assume that such a comparison takes one time unit. Your goal is to find an algorithm that makes a minimum number of
comparisons to determine the grouping. Remember that you may not directly compare two red jugs or two blue jugs.

\begin{description}
\item[a. \hspace{9pt}] Describe a deterministic algorithm that uses $\Theta(n^2)$ comparisons to group the jugs into pairs.


\item[b. \hspace{9pt}] Prove a lower bound of $\Omega(n \lg n)$ for the number of comparisons an algorithm solving this problem must make.

\item[c. \hspace{9pt}] Give a randomized algorithm whose expected number of comparisons is $O(n \lg n)$, and prove that this bound is correct. What is the worst-case number of
comparisons for your algorithm?

\end{description}

\answer

\begin{description}

\item[a. \hspace{9pt}] The algorithm is given below. Since there are 2 \textbf{foreach} loops, each runs in $\Theta(n)$ time, the algorithm will run in $\Theta(n^2)$ time.
\end{description}

\begin{algorithm}[H]
\caption{\textsc{Find-Jugs}}
\ForEach{red jug}{
  \ForEach{blue jug}{
    \If{the red jug and blue jug has same volumne}{
      mark them as a pair
    }
  }
}
\end{algorithm}

\begin{description}
\item[b. \hspace{9pt}] We prove this by reducing sorting to this problem. For a permutation of $(1, 2, \ldots, n)$, which we mark as $a_1, a_2, \ldots, a_n$, prepare red jugs
with size $a_1, a_2, \ldots, a_n$, and blue jugs with size $1, 2, 3, \ldots, n$. When we solve the jug finding problem, a pair $(a_i, j)$ means the value $a_i$ ended up in the
$i$th position in $(1, 2, \ldots, n)$. So we can solve sorting problem by converting it to this jug finding problem. Since sorting is proved to have lower bound $\Omega(n \lg n)$,
the jug finding problem must have lower bound equal to or higher than $\Omega(n \lg n)$, that means $\Omega(n \lg n)$ is a lower bound for this kind of problem.

\item[c. \hspace{9pt}] The algorithm is given below. It behaves like \textsc{Quick-Sort}, dividing the problem into smaller problems.
By the same reasoning as \textsc{Quick-Sort}, we know that \textsc{Quick-Find-Jugs} has expected number of comparisons in $O(n\lg n)$.
And similar to \textsc{Quick-Sort}, the worst-case number of comparisons of \textsc{Quick-Find-Jugs} is $\Theta(n^2)$, when both red jugs and blue jugs are ``sorted''.

\end{description}

\begin{algorithm}[H]
\caption{\textsc{Quick-Find-Jugs}(Red jugs, Blue jugs)}
\If{there is only one red jug $r$ and one blue jug $b$}{
  \Return $\left\{(r, b)\right\}$\\
}\ElseIf{there is no jugs left}{
  \Return $\emptyset$
}
$S \leftarrow \emptyset, R\_smaller \leftarrow \emptyset, R\_larger \leftarrow \emptyset, B\_smaller \leftarrow \emptyset, B\_larger \leftarrow \emptyset$\\
randomly pick a red jug $R$\\
\ForEach{blue jug $b$}{
  \If{$b$ has same volumn as $R$}{
    mark the blue jug as $B$\\
    add $(R, B)$ into $S$\\
  }\ElseIf{$b$ is larger than $R$}{
    put $b$ into $B\_larger$\\
  }\Else{
    put $b$ into $B\_smaller$\\
  }
}
\ForEach{red jug $r$}{
  \If{$r$ is larger than $B$}{
    put $r$ into $R\_larger$\\
  }\ElseIf{$r$ is smaller than $R$}{
    put $r$ into $R\_smaller$\\
  }
}
$S \leftarrow S \cup $ \textsc{Quick-Find-Jugs}($R\_smaller, B\_smaller$)\\
$S \leftarrow S \cup $ \textsc{Quick-Find-Jugs}($R\_larger, B\_larger$)\\
\Return $S$\\
\end{algorithm}
\qed

\problem{9.3-1}
In the algorithm \textsc{Select}, the input elements are divided into groups of $5$. Will the algorithm work in linear time if they are divided into groups of $7$? Argue that
\textsc{Select} does not run in linear time if groups of $3$ are used.
\answer

By similar analyze, we know that the smaller part has at least

$$ 4\left(\left\lceil\frac{1}{2}\left\lceil\frac{n}{7}\right\rceil\right\rceil-2\right)\geq \frac{2n}{7} - 8.$$

So, in worst case, \textsc{Select} is recursively running on $\frac{5n}{7} + 8$ elements. Now we obtain the recurrence:

\begin{equation*}
T(n) \leq \left\{
  \begin{array}{ll}
    \Theta(1)     & \text{if $n \leq 140$,}\\
    T\left(\left\lceil\frac{n}{7}\right\rceil\right) + T\left(\frac{5n}{7} + 8\right) + O(n) & \text{if $n > 140$.}
  \end{array}
\right.
\end{equation*}

By substitution we have:

\begin{eqnarray*}
T(n)  &\leq& c\left(\left\lceil\frac{n}{7}\right\rceil\right) + c\left(\frac{5n}{7} + 8\right) + bn\\
&\leq& \frac{cn}{7} + \frac{5cn}{7} + 8c + bn\\
&=&cn + \left(8c + bn - \frac{cn}{7}\right)
\end{eqnarray*}

Now we only need $8c + \left(b - \frac{c}{7}\right)n \leq 0$, which could be satisfied by choosing $c > 21b$.

If groups of $3$ is chosen, then we would smaller part with at least

$$2\left(\left\lceil\frac{1}{2}\left\lceil\frac{n}{3}\right\rceil\right\rceil -2\right) \geq \frac{n}{3} - 4.$$

So in worst case, the algorithm will run on $\frac{2n}{3} + 4$ elements recursively. And we will have the recurrence:

\begin{eqnarray*}
T(n) &=& T\left(\left\lceil\frac{n}{3}\right\rceil\right) + T\left(\frac{2n}{3} + 4\right) + O(n)\\
&\geq& T\left(\frac{n}{3}\right) + T\left(\frac{2n}{3} + 4\right) + O(n)\\
\end{eqnarray*}

Since $\frac{1}{3} + \frac{2}{3} = 1 \nless 1$,  we cannot prove that the algorithm runs in linear time.
\qed

\problem{9-2 Weighted median}
For $n$ distinct elements $x_1, x_2, \ldots, x_n$ with positive weights $w_1, w_2, \ldots, w_n$ such that $\sum_{i = 1}^{n}w_i = 1$, the \textsl{\textbf{weighted (lower) median}} is the 
element $x_k$ satisfying

$$\sum_{x_i < x_k}w_i < \frac{1}{2} \text{ \hspace{9pt} and \hspace{6pt}  } \sum_{x_i>x_k}w_i \leq \frac{1}{2}.$$

\begin{description}
\item[a. \hspace{9pt}] Argue that the median of $x_1, x_2, \ldots, x_n$ is the weighted median of the $x_i$ with weights $w_i = \frac{1}{n}$ for $i = 1, 2, \ldots, n$.

\item[b. \hspace{9pt}] Show how to compute the weighted median of $n$ elements in $O(n \lg n)$ worst-case time using sorting.

\item[c. \hspace{9pt}] Show how to compute the weighted median $\Theta(n)$ worst-case time using a linear-time median algorithm.
\end{description}

The \textsl{\textbf{post-office location problem}} is defined as follows. We are given $n$ points $p_1, p_2, \ldots, p_n$ with associated weights $w_1, w_2, \ldots, w_n$. We wish to find
a point $p$ (not necessarily one of the input points) that minimizes the sum $\sum_{i = 1}^n w_i d(p, p_i)$, where $d(a, b)$ is the distance between points $a$ and $b$.

\begin{description}
\item[d. \hspace{9pt}] Argue that the weighted median is a best solution for the 1-dimensional post-office location problem, in which points are simply real numbers and the distance between
points $a$ and $b$ is $d(a, b) = |a-b|$.

\item[e. \hspace{9pt}] Find the best solution for the 2-dimensional post-office location problem, in which the points are $(x, y)$ coordinate pairs and the distance between points 
$a = (x_1, y_1)$ and $b = (x_2, y_2)$ is the \textsl{\textbf{Manhattan distance}} given by $d(a, b) = |x_1 - x_2| + |y_1 - y_2|$.
\end{description}

\answer
\begin{description}
\item[a. \hspace{9pt}] First, consider the case when $n = 2k$. In this case, the median is $x_{\lceil\frac{n}{2}\rceil} = x_k$. We have

$$\sum_{x_i < x_k}w_i = \frac{k - 1}{n} = \frac{k - 1}{2k} < \frac{1}{2},$$

and

$$\sum_{x_i > x_k}w_i = \frac{k}{n} = \frac{k}{2k} = \frac{1}{2}.$$

When $n = 2k + 1$, the median is $x_{\lceil\frac{n}{2}\rceil} = x_{k+1}$. In this case, we have

$$ \sum_{x_i < x_{k + 1}}w_i = \frac{k}{n} = \frac{k}{2k + 1} < \frac{1}{2}, $$
and

$$\sum_{x_i > x_{k +1}} w_i = \frac{k}{n} = \frac{k}{2k + 1} < \frac{1}{2}.$$

So we can conclude that the median of $x_1, x_2, \ldots, x_n$ is the weighted median of the $x_i$ with weights $w_i = \frac{1}{n}$.

\item[b. \hspace{9pt}] We can sort an array in worst-case time $O(n\lg n)$ with heap sort. And it takes $\Theta(n)$ time to check if an element is the weighted median.
So using a binary-search fasion we could find weighted median in a  sorted array in $\Theta(\lg n)$ iterations. Since each iteration uses $\Theta(n)$ time, we could find the
weighted median in $\Theta(n \lg n)$ time. So the overall running time is $O(n\lg n)$ for sorting, and $\Theta(n \lg n)$ to find the weighted median. In conclusion, the 
job could be done in $\Theta(n \lg n)$.


\item[c. \hspace{9pt}] The following \textsc{Linear-Weighted-Median} algorithm is gauranteed to find weighted median in $\Theta(n)$. It uses \textsc{Select} to select the pivot element, and
divide input array into two smaller parts by partitioning. To get the weighted median, call \textsc{Linear-Weighted-Median}$(A, 1, n, 0)$.

\textsc{Select} finds the median in $O(n)$ time, and partitioning takes $\Theta(n)$ time. Since $a$ is the median in $A[p\ldots r]$, the input array is nearly
equaly partitioned into two parts. Even in the worst case the problem size is reduced by half after each function call. So we have the running time:

$$T(n) \leq \Theta(n) + T\left(\left\lceil\frac{n}{2}\right\rceil\right).$$

It is obvious that $T(n) = \Theta(n)$.

\end{description}

\begin{algorithm}[H]
\caption{\textsc{Linear-Weighted-Median}$(A, p, r, w)$}
\tcp{$A, p, r$: denotes the input array $A[p\ldots r]$ to be processed}
\tcp{$w$: the weight of $A[1\ldots p - 1]$. this is a helper variable}
\If{$p = r$} {
  \Return $A[p]$\\
}\ElseIf{$p > r$}{
  \Return null
}
$a \leftarrow $\textsc{Select}$\left(A, p, r, \left\lceil\frac{r - p + 1}{2}\right\rceil\right)$\\
Partition $A$ by $a$. Let $k$ be the final position of $a$, make sure $A[p\ldots k - 1] \leq a \leq A[k + 1 \ldots r]$\\
$u\leftarrow \sum_{i = p}^{k - 1}w_i$\\
\If{$w + u \geq \frac{1}{2}$}{
  \tcp{The weighted median must be in the left part}
  \Return \textsc{Linear-Weighted-Median}$(A, p, k - 1, w)$
}\ElseIf{$w + u + w_k \geq \frac{1}{2}$}{
  \tcp{The weighted median is $a$}
  \Return $a$
}\Else{
  \tcp{The weighted median must be in the right part}
  \Return \textsc{Linear-Weighted-Median}$(A, k + 1, r, w + u + w_k)$
}
\end{algorithm}


\begin{description}

\item[d. \hspace{9pt}] First of all, consider the trivial case of $n = 1$. Since there is only one point, the weighted median could only be this point, and this point
is the solution for the post-office location problem. So for this trivial case, weighted median is the solution for post-office location problem.

Suppose the post-offices are located at positions $x_1, x_2, x_3, \ldots, x_n$, where $x_1 = 0$ and $x_i < x_{i + 1}$. Let $x$ denote the solution for post-office location, we claim that
$x\nless x_1 = 0$. Suppose $x < x_1$ is a solution, then the cost is $\sum_{i = 1}^n{w_i(x_i - x)}$, but if we choose $x_1$ as a solution, then the cost is
$\sum_{i = 2}^n{w_i(x_i - x_1)} < \sum_{i = 1}^n{w_i(x_i - x)}$. From this contradiction we know that $x\nless x_1$, and similarly we can prove that $x$ cannot be greater than $x_n$,
this means $x_1 \leq x \leq x_n$.

Now consider the target function

$$y = \sum_{i = 1}^n{w_i|x - x_i|}.$$

This function has many segments, and in each segment it is a linear function. So we know that the global minimum point lies in the end-points $x_1, x_2, x_3, \ldots, x_n$.

Suppose a point $x = x_k$ is chosen, the cost is:

$$y_1 = \sum_{i = 1}^{k - 1}{w_i(x_k - x_i)} + \sum_{i = k + 1}^n{w_i(x_i - x_k)}.$$

Now we consider how will the cost change if $x$ is increased by a very small positive value $\Delta$, where $\Delta$ is so small that $x$ will not
go into another segment. The cost will change to:

\begin{eqnarray*}
y_2 &=& \sum_{i = 1}^{k - 1}w_i(x_k + \Delta - x_i) + w_k \Delta + \sum_{i = k+1}^{n}{w_i(x_i - x_k - \Delta)}\\
&=& y_1 + \Delta\times\left(\sum_{i = 1}^k w_i - \sum_{i = k+1}^n w_i \right).
\end{eqnarray*}

So we know that $y$ will increase with $x$  if and only if $\sum_{i = 1}^k w_i \geq \sum_{i = k+1}^n w_i$. When $y$ achieves global minimum value at $x_k$,
it must be true that $y$ is decreasing for $x< x_k$ and increasing for $x> x_k$. Such a $k$ satisfies that:

$$\sum_{i = 1}^{k - 1}w_i + w_k \geq \sum_{i = k  + 1}^{n}w_i \hspace{9pt}\text{and}\hspace{9pt} \sum_{i = 1}^{k - 1}w_i < w_k + \sum_{i = k  + 1}^{n}w_i.$$

With $\sum_{k = 1}^n w_i = 1$ we can easy get that:

$$\sum_{i = 1}^{k - 1}w_i < \frac{1}{2} \hspace{9pt}\text{and}\hspace{9pt} \sum_{i = k + 1}^n w_i \leq \frac{1}{2},$$

which is indeed the definition of weighted median, given the fact that $x_i < x_{i + 1}$.


\item[e. \hspace{9pt}] We have the target function

$$ z = \sum_{i = 1}^n{w_i\left(|x - x_i| + |y - y_i|\right)} = \sum_{i = 1}^n{w_i|x - x_i|}  + \sum_{i = 1}^n{w_i|y - y_i|}.$$

So we could first solve the problem for $x$-axis and $y$-axis separately, and combine them to get the final solution. In other words, the solution is
$(x_i, y_j)$ where $x_i$ is the weighted median on $x_1, x_2, \ldots, x_n$ and $y_j$ is the weighted median on $y_1, y_2, \ldots, y_n$.
\end{description}
\qed


